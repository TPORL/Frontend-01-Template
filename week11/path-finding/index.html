<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>Path-finding</title>
    <style>
      #container {
        width: 699px;
        vertical-align: top;
        display: inline-grid;
        grid-template-rows: repeat(100, 6px);
        grid-template-columns: repeat(100, 6px);
        gap: 1px;
      }

      .cell {
        user-select: none;
        background-color: #ddd;
      }

      .wall {
        background-color: #333;
      }

      .area {
        background-color: #4b8;
      }

      .path {
        background-color: #66f;
      }

      .start {
        background-color: #ff6;
      }

      .end {
        background-color: #f66;
      }
    </style>
  </head>
  <body>
    <div id="container"></div>
    <div>
      <button onclick="save()">Save</button>
      <button onclick="clean()">Clean</button>
      <button onclick="reset()">Reset</button>
      <button onclick="run()">Run</button>
    </div>

    <script src="./defaultMap.js"></script>
    <script>
      let map = JSON.parse(localStorage.getItem('map')) || [...defaultMap]
      let isRuning = false
      let isMouseDown = false
      let isEraserMode = false

      const container = document.querySelector('#container')
      const frag = document.createDocumentFragment()
      map.forEach((val, i) => {
        const cell = document.createElement('cell')
        cell.classList.add('cell')
        val === 1 && cell.classList.add('wall')
        cell.addEventListener('mouseover', () => {
          if (!isMouseDown || isRuning) return
          if (isEraserMode) {
            map[i] = 0
            cell.classList.remove('wall')
          } else {
            map[i] = 1
            cell.classList.add('wall')
          }
        })
        frag.appendChild(cell)
      })
      container.appendChild(frag)

      container.addEventListener('contextmenu', (evt) => {
        evt.preventDefault()
      })

      container.addEventListener('mousedown', (evt) => {
        isMouseDown = true
        isEraserMode = evt.which === 3
      })

      document.addEventListener('mouseup', () => {
        isMouseDown = false
      })

      const cells = document.querySelectorAll('.cell')

      function save() {
        if (isRuning) return
        localStorage.setItem('map', JSON.stringify(map))
      }

      function clean() {
        if (isRuning) return
        map.forEach((val, i) => {
          map[i] = 0
          cells[i].className = 'cell'
        })
      }

      function reset() {
        if (isRuning) return
        map = [...defaultMap]
        map.forEach((val, i) => {
          map[i] = val
          cells[i].className = 'cell'
          if (val) {
            cells[i].classList.add('wall')
          } else {
            cells[i].classList.remove('wall')
          }
        })
      }

      function restart() {
        if (!isRuning) return
        map.forEach((val, i) => {
          map[i] = val
          cells[i].className = 'cell'
          if (val) {
            cells[i].classList.add('wall')
          } else {
            cells[i].classList.remove('wall')
          }
        })
      }

      function sleep(ms = 0) {
        return new Promise((resolve) => setTimeout(resolve, ms))
      }

      async function findPath(map, start, end) {
        const queue = [start]
        const table = [...map]

        async function addPoint(x, y, prev) {
          const index = x + y * 100

          if (x < 0 || x > 99 || y < 0 || y > 99) return false
          if (table[index] !== 0) return false

          // await sleep(0)
          cells[index].classList.add('area')
          table[index] = prev
          queue.push([x, y])
          return true
        }

        while (queue.length) {
          let [x, y] = queue.shift()

          if (x === end[0] && y === end[1]) {
            const path = []
            while (x !== start[0] || y !== start[1]) {
              path.unshift([x, y])
              await sleep(0)
              cells[x + y * 100].classList.add('path')
              ;[x, y] = table[x + y * 100]
            }
            path.unshift([x, y])
            return path
          }

          const up = await addPoint(x, y - 1, [x, y])
          const down = await addPoint(x, y + 1, [x, y])
          const left = await addPoint(x - 1, y, [x, y])
          const right = await addPoint(x + 1, y, [x, y])

          ;(up || left) && (await addPoint(x - 1, y - 1, [x, y]))
          ;(up || right) && (await addPoint(x + 1, y - 1, [x, y]))
          ;(down || right) && (await addPoint(x + 1, y + 1, [x, y]))
          ;(down || left) && (await addPoint(x - 1, y + 1, [x, y]))
        }

        return null
      }

      async function run() {
        if (isRuning) return
        isRuning = true

        restart()

        const start = [0, 0]
        const end = [50, 50]
        cells[start[0] + start[1] * 100].classList.add('start')
        cells[end[0] + end[1] * 100].classList.add('end')

        const path = await findPath(map, start, end)
        console.log(path)

        isRuning = false
      }
    </script>
  </body>
</html>
